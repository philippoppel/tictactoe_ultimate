<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ultimate Tic Tac Toe - Mobile Edition</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        .game-container {
            max-width: 100vw;
            min-height: 100vh;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            font-size: 1.5rem;
            margin: 10px 0;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            background: linear-gradient(45deg, #f093fb 0%, #f5576c 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .mode-selector {
            width: 100%;
            max-width: 400px;
            margin: 20px 0;
        }

        .mode-button {
            width: 100%;
            padding: 20px;
            margin: 10px 0;
            border: none;
            border-radius: 20px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            position: relative;
            overflow: hidden;
        }

        .mode-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            transition: width 0.6s, height 0.6s;
        }

        .mode-button:active::before {
            width: 300px;
            height: 300px;
        }

        .mode-button.host {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .mode-button.join {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .mode-button.computer {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            color: #333;
        }

        .connection-panel {
            width: 100%;
            max-width: 400px;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .connection-panel h2 {
            margin-top: 0;
            font-size: 1.3rem;
        }

        .connection-input {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 15px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 1.1rem;
            transition: all 0.3s ease;
        }

        .connection-input:focus {
            outline: none;
            border-color: rgba(255,255,255,0.6);
            background: rgba(255,255,255,0.2);
        }

        .connection-input::placeholder {
            color: rgba(255,255,255,0.6);
        }

        .connection-button {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            border: none;
            border-radius: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .game-code {
            font-size: 2rem;
            font-weight: bold;
            text-align: center;
            padding: 20px;
            background: rgba(255,255,255,0.2);
            border-radius: 15px;
            margin: 15px 0;
            letter-spacing: 2px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .status {
            text-align: center;
            margin: 15px 0;
            font-size: 1.1rem;
            font-weight: 500;
        }

        .status.connected {
            color: #4ade80;
        }

        .status.waiting {
            color: #fbbf24;
        }

        .info {
            width: 100%;
            max-width: 400px;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 15px;
            margin-bottom: 15px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .info div {
            margin: 5px 0;
            font-size: 1rem;
        }

        .ultimate-board {
            width: 100%;
            max-width: 400px;
            aspect-ratio: 1;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            padding: 10px;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            opacity: 0.3;
            transition: opacity 0.3s ease;
        }

        .ultimate-board.active {
            opacity: 1;
        }

        .big-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            height: 100%;
        }

        .small-board {
            background: rgba(255,255,255,0.1);
            padding: 4px;
            border-radius: 10px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            position: relative;
        }

        .small-board.active {
            border-color: #fbbf24;
            background: rgba(251,191,36,0.2);
            box-shadow: 0 0 20px rgba(251,191,36,0.4);
        }

        .small-board.won-X {
            background: rgba(96,165,250,0.3);
        }

        .small-board.won-O {
            background: rgba(248,113,113,0.3);
        }

        .small-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            height: 100%;
        }

        .cell {
            aspect-ratio: 1;
            background: rgba(255,255,255,0.1);
            border: none;
            cursor: pointer;
            font-size: 1.2rem;
            font-weight: bold;
            color: white;
            transition: all 0.2s ease;
            border-radius: 5px;
            position: relative;
            overflow: hidden;
        }

        .cell::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            transition: width 0.4s, height 0.4s;
        }

        .cell:active::before {
            width: 100px;
            height: 100px;
        }

        .cell:active {
            transform: scale(0.95);
        }

        .cell:disabled {
            cursor: not-allowed;
            opacity: 0.7;
        }

        .cell.X {
            color: #60a5fa;
            text-shadow: 0 0 10px rgba(96,165,250,0.8);
        }

        .cell.O {
            color: #f87171;
            text-shadow: 0 0 10px rgba(248,113,113,0.8);
        }

        .board-winner {
            position: absolute;
            font-size: 3rem;
            font-weight: bold;
            opacity: 0.9;
            pointer-events: none;
            transform: translate(-50%, -50%);
            top: 50%;
            left: 50%;
            animation: winnerPulse 1s ease-in-out infinite;
        }

        @keyframes winnerPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }

        .winner-message {
            margin-top: 20px;
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            width: 100%;
            max-width: 400px;
        }

        .reset-button, .back-button {
            flex: 1;
            padding: 15px;
            font-size: 1.1rem;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .reset-button:active, .back-button:active {
            transform: scale(0.95);
        }

        .hidden {
            display: none !important;
        }

        /* Loading animation */
        .thinking {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Responsive adjustments */
        @media (max-width: 380px) {
            .cell {
                font-size: 1rem;
            }
            .board-winner {
                font-size: 2.5rem;
            }
        }

        @media (max-height: 700px) {
            h1 {
                font-size: 1.3rem;
                margin: 5px 0;
            }
            .game-container {
                padding: 5px;
            }
            .info {
                padding: 10px;
            }
            .ultimate-board {
                padding: 8px;
            }
        }
    </style>
</head>
<body>
<div class="game-container">
    <h1>Ultimate Tic Tac Toe</h1>

    <div id="modeSelector" class="mode-selector">
        <h2 style="text-align: center; margin-bottom: 20px;">W√§hle einen Spielmodus:</h2>
        <button class="mode-button host" onclick="showHostPanel()">üéÆ Online-Spiel erstellen</button>
        <button class="mode-button join" onclick="showJoinPanel()">üîó Online-Spiel beitreten</button>
        <button class="mode-button computer" onclick="startComputerGame()">ü§ñ Gegen UNBESIEGBARE KI</button>
    </div>

    <div id="connectionPanel" class="connection-panel hidden">
        <h2 id="connectionTitle">Verbindung</h2>

        <div id="hostSection" class="hidden">
            <p>Teile diesen Code mit deinem Freund:</p>
            <div class="game-code" id="gameCode">Wird generiert...</div>
            <div class="status waiting">Warte auf Mitspieler...</div>
        </div>

        <div id="joinSection" class="hidden">
            <p>Gib den Spiel-Code ein:</p>
            <input type="text" id="joinCode" class="connection-input" placeholder="Spiel-Code eingeben" autocomplete="off">
            <button class="connection-button" onclick="joinGame()">Spiel beitreten</button>
        </div>

        <div id="connectionStatus" class="status"></div>
    </div>

    <div class="info hidden" id="gameInfo">
        <div>Du spielst als: <span id="playerSymbol" style="font-weight: bold;"></span></div>
        <div>Aktueller Spieler: <span class="current-player" id="currentPlayer">X</span></div>
        <div id="boardHint"></div>
    </div>

    <div class="ultimate-board" id="ultimateBoard">
        <div class="big-grid" id="gameBoard"></div>
    </div>

    <div id="winnerMessage" class="winner-message"></div>

    <div class="button-group hidden" id="gameButtons">
        <button class="reset-button" onclick="resetGame()">üîÑ Neues Spiel</button>
        <button class="back-button" onclick="backToMenu()">üè† Hauptmen√º</button>
    </div>
</div>

<script>
    let peer = null;
    let conn = null;
    let isHost = false;
    let mySymbol = '';
    let opponentSymbol = '';
    let isMyTurn = false;
    let gameMode = '';

    let currentPlayer = 'X';
    let activeBoard = null;
    let boards = Array(9).fill(null).map(() => Array(9).fill(''));
    let boardWinners = Array(9).fill(null);
    let gameWon = false;

    const winPatterns = [
        [0, 1, 2], [3, 4, 5], [6, 7, 8],
        [0, 3, 6], [1, 4, 7], [2, 5, 8],
        [0, 4, 8], [2, 4, 6]
    ];

    function generateGameCode() {
        return Math.random().toString(36).substring(2, 8).toUpperCase();
    }

    function showHostPanel() {
        gameMode = 'online';
        document.getElementById('modeSelector').classList.add('hidden');
        document.getElementById('connectionPanel').classList.remove('hidden');
        document.getElementById('hostSection').classList.remove('hidden');
        document.getElementById('connectionTitle').textContent = 'üéÆ Spiel erstellen';

        const gameCode = generateGameCode();
        peer = new Peer(gameCode);

        peer.on('open', (id) => {
            document.getElementById('gameCode').textContent = id;
            console.log('Game code:', id);
        });

        peer.on('connection', (connection) => {
            conn = connection;
            setupConnection();
            isHost = true;
            mySymbol = 'X';
            opponentSymbol = 'O';
            isMyTurn = true;
        });
    }

    function showJoinPanel() {
        gameMode = 'online';
        document.getElementById('modeSelector').classList.add('hidden');
        document.getElementById('connectionPanel').classList.remove('hidden');
        document.getElementById('joinSection').classList.remove('hidden');
        document.getElementById('connectionTitle').textContent = 'üîó Spiel beitreten';
    }

    function joinGame() {
        const code = document.getElementById('joinCode').value.toUpperCase();
        if (!code) {
            alert('Bitte gib einen Spiel-Code ein!');
            return;
        }

        peer = new Peer();

        peer.on('open', () => {
            conn = peer.connect(code);
            setupConnection();
            isHost = false;
            mySymbol = 'O';
            opponentSymbol = 'X';
            isMyTurn = false;
        });
    }

    function setupConnection() {
        conn.on('open', () => {
            document.getElementById('connectionStatus').textContent = '‚úÖ Verbunden!';
            document.getElementById('connectionStatus').classList.add('connected');
            startOnlineGame();
        });

        conn.on('data', (data) => {
            if (data.type === 'move') {
                receiveMove(data.boardIndex, data.cellIndex);
            } else if (data.type === 'reset') {
                resetGame();
            }
        });

        conn.on('close', () => {
            document.getElementById('connectionStatus').textContent = '‚ùå Verbindung getrennt!';
            document.getElementById('connectionStatus').classList.remove('connected');
            alert('Die Verbindung wurde getrennt!');
        });
    }

    function startOnlineGame() {
        document.getElementById('connectionPanel').classList.add('hidden');
        document.getElementById('gameInfo').classList.remove('hidden');
        document.getElementById('ultimateBoard').classList.add('active');
        document.getElementById('gameButtons').classList.remove('hidden');

        document.getElementById('playerSymbol').textContent = mySymbol;
        document.getElementById('playerSymbol').style.color = mySymbol === 'X' ? '#60a5fa' : '#f87171';

        initGame();
        updateTurnIndicator();
    }

    function startComputerGame() {
        gameMode = 'computer';
        document.getElementById('modeSelector').classList.add('hidden');
        document.getElementById('gameInfo').classList.remove('hidden');
        document.getElementById('ultimateBoard').classList.add('active');
        document.getElementById('gameButtons').classList.remove('hidden');

        document.getElementById('playerSymbol').textContent = 'X (Du)';
        document.getElementById('playerSymbol').style.color = '#60a5fa';

        mySymbol = 'X';
        opponentSymbol = 'O';
        isMyTurn = true;

        initGame();
    }

    function updateTurnIndicator() {
        if (gameMode === 'online') {
            const boardHint = document.getElementById('boardHint');
            if (isMyTurn) {
                boardHint.style.color = '#4ade80';
                if (activeBoard === null) {
                    boardHint.textContent = '‚úÖ Dein Zug! W√§hle ein beliebiges freies Feld.';
                } else {
                    const row = Math.floor(activeBoard / 3) + 1;
                    const col = (activeBoard % 3) + 1;
                    boardHint.textContent = `‚úÖ Dein Zug! Spiele in Feld (${row}, ${col}).`;
                }
            } else {
                boardHint.style.color = '#fbbf24';
                boardHint.innerHTML = '‚è≥ Warte auf deinen Gegner...';
            }
        } else {
            updateBoardHint();
        }
    }

    function initGame() {
        const gameBoard = document.getElementById('gameBoard');
        gameBoard.innerHTML = '';

        for (let boardIndex = 0; boardIndex < 9; boardIndex++) {
            const smallBoard = document.createElement('div');
            smallBoard.className = 'small-board';
            smallBoard.id = `board-${boardIndex}`;

            const smallGrid = document.createElement('div');
            smallGrid.className = 'small-grid';

            for (let cellIndex = 0; cellIndex < 9; cellIndex++) {
                const cell = document.createElement('button');
                cell.className = 'cell';
                cell.onclick = () => makeMove(boardIndex, cellIndex);
                cell.id = `cell-${boardIndex}-${cellIndex}`;
                smallGrid.appendChild(cell);
            }

            smallBoard.appendChild(smallGrid);
            gameBoard.appendChild(smallBoard);
        }
        updateActiveBoards();
        if (gameMode === 'online') {
            updateTurnIndicator();
        } else {
            updateBoardHint();
        }
    }

    function makeMove(boardIndex, cellIndex) {
        if (gameWon || boards[boardIndex][cellIndex] || boardWinners[boardIndex]) return;
        if (activeBoard !== null && activeBoard !== boardIndex) return;

        if (gameMode === 'online') {
            if (!isMyTurn || currentPlayer !== mySymbol) return;
            conn.send({ type: 'move', boardIndex, cellIndex });
        } else if (gameMode === 'computer') {
            if (currentPlayer !== mySymbol) return;
        }

        executeMove(boardIndex, cellIndex);
    }

    function receiveMove(boardIndex, cellIndex) {
        executeMove(boardIndex, cellIndex);
    }

    function executeMove(boardIndex, cellIndex) {
        boards[boardIndex][cellIndex] = currentPlayer;
        const cell = document.getElementById(`cell-${boardIndex}-${cellIndex}`);
        cell.textContent = currentPlayer;
        cell.classList.add(currentPlayer);
        cell.disabled = true;

        if (checkSmallBoardWin(boardIndex, currentPlayer)) {
            boardWinners[boardIndex] = currentPlayer;
            const smallBoard = document.getElementById(`board-${boardIndex}`);
            smallBoard.classList.add(`won-${currentPlayer}`);

            const winnerSymbol = document.createElement('div');
            winnerSymbol.className = 'board-winner';
            winnerSymbol.textContent = currentPlayer;
            winnerSymbol.style.color = currentPlayer === 'X' ? '#60a5fa' : '#f87171';
            smallBoard.appendChild(winnerSymbol);
            disableSmallBoard(boardIndex);

            if (checkUltimateWin(currentPlayer)) {
                gameWon = true;
                const winnerText = gameMode === 'online'
                    ? (currentPlayer === mySymbol ? 'üéâ Du hast gewonnen! üéâ' : 'üòî Dein Gegner hat gewonnen!')
                    : (currentPlayer === mySymbol ? 'üéâ Du hast gewonnen! üéâ' : 'ü§ñ Die KI hat gewonnen!');
                document.getElementById('winnerMessage').textContent = winnerText;
                disableAllBoards();
                return;
            }
        }

        if (checkDraw()) {
            gameWon = true;
            document.getElementById('winnerMessage').textContent = 'ü§ù Unentschieden!';
            return;
        }

        currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
        document.getElementById('currentPlayer').textContent = currentPlayer;

        activeBoard = boardWinners[cellIndex] !== null || isBoardFull(cellIndex) ? null : cellIndex;

        updateActiveBoards();

        if (gameMode === 'online') {
            isMyTurn = !isMyTurn;
            updateTurnIndicator();
        } else {
            isMyTurn = !isMyTurn;
            updateBoardHint();
            if (!isMyTurn && !gameWon) {
                document.getElementById('ultimateBoard').style.pointerEvents = 'none';
                setTimeout(() => {
                    makeComputerMove();
                    document.getElementById('ultimateBoard').style.pointerEvents = 'auto';
                }, 300);
            }
        }
    }

    // Computer AI Logic
    function makeComputerMove() {
        if (gameWon) return;

        const searchDepth = 6;
        let bestMove = { score: -Infinity, move: null };
        const availableMoves = getAvailableMoves();

        if (availableMoves.length === 0) return;
        if (availableMoves.length === 1) {
            bestMove.move = availableMoves[0];
        } else {
            for (const move of availableMoves) {
                boards[move.boardIndex][move.cellIndex] = opponentSymbol;
                const oldWinner = boardWinners[move.boardIndex];
                if (checkSmallBoardWin(move.boardIndex, opponentSymbol)) {
                    boardWinners[move.boardIndex] = opponentSymbol;
                }

                const score = minimax(searchDepth, false, -Infinity, Infinity, move);

                boards[move.boardIndex][move.cellIndex] = '';
                boardWinners[move.boardIndex] = oldWinner;

                if (score > bestMove.score) {
                    bestMove.score = score;
                    bestMove.move = move;
                }
            }
        }

        if (!bestMove.move) {
            bestMove.move = availableMoves[Math.floor(Math.random() * availableMoves.length)];
        }

        executeMove(bestMove.move.boardIndex, bestMove.move.cellIndex);
    }

    function minimax(depth, isMaximizing, alpha, beta, lastMove) {
        const score = evaluateBoard();
        if (Math.abs(score) > 5000 || depth === 0 || gameWon) {
            return score + depth;
        }

        const nextActiveBoard = (boardWinners[lastMove.cellIndex] !== null || isBoardFull(lastMove.cellIndex)) ? null : lastMove.cellIndex;
        const moves = getAvailableMoves(nextActiveBoard);

        if (isMaximizing) {
            let maxEval = -Infinity;
            for (const move of moves) {
                boards[move.boardIndex][move.cellIndex] = opponentSymbol;
                const oldWinner = boardWinners[move.boardIndex];
                if (checkSmallBoardWin(move.boardIndex, opponentSymbol)) {
                    boardWinners[move.boardIndex] = opponentSymbol;
                }

                const evaluation = minimax(depth - 1, false, alpha, beta, move);

                boards[move.boardIndex][move.cellIndex] = '';
                boardWinners[move.boardIndex] = oldWinner;

                maxEval = Math.max(maxEval, evaluation);
                alpha = Math.max(alpha, evaluation);
                if (beta <= alpha) break;
            }
            return maxEval;
        } else {
            let minEval = Infinity;
            for (const move of moves) {
                boards[move.boardIndex][move.cellIndex] = mySymbol;
                const oldWinner = boardWinners[move.boardIndex];
                if (checkSmallBoardWin(move.boardIndex, mySymbol)) {
                    boardWinners[move.boardIndex] = mySymbol;
                }

                const evaluation = minimax(depth - 1, true, alpha, beta, move);

                boards[move.boardIndex][move.cellIndex] = '';
                boardWinners[move.boardIndex] = oldWinner;

                minEval = Math.min(minEval, evaluation);
                beta = Math.min(beta, evaluation);
                if (beta <= alpha) break;
            }
            return minEval;
        }
    }

    function evaluateBoard() {
        if (checkUltimateWin(opponentSymbol)) return 10000;
        if (checkUltimateWin(mySymbol)) return -10000;

        let totalScore = 0;
        totalScore += evaluateLine(boardWinners, opponentSymbol, mySymbol) * 150;

        for (let i = 0; i < 9; i++) {
            if (boardWinners[i] === null) {
                totalScore += evaluateSmallBoard(i);
            }
        }

        return totalScore;
    }

    function evaluateLine(board, p1, p2) {
        let score = 0;
        for (const pattern of winPatterns) {
            let p1_pieces = 0;
            let p2_pieces = 0;
            for (const index of pattern) {
                if (board[index] === p1) p1_pieces++;
                else if (board[index] === p2) p2_pieces++;
            }
            if (p1_pieces === 2 && p2_pieces === 0) score += 1;
            if (p2_pieces === 2 && p1_pieces === 0) score -= 1;
        }
        return score;
    }

    function evaluateSmallBoard(boardIndex) {
        let score = 0;
        const board = boards[boardIndex];

        score += evaluateLine(board, opponentSymbol, mySymbol) * 10;

        if(board[4] === opponentSymbol) score += 4;
        else if(board[4] === mySymbol) score -= 4;

        const corners = [0, 2, 6, 8];
        corners.forEach(corner => {
            if(board[corner] === opponentSymbol) score += 2;
            else if(board[corner] === mySymbol) score -= 2;
        });

        if (boardIndex === 4) {
            return score * 1.5;
        }

        return score;
    }

    function getAvailableMoves(currentActiveBoard = activeBoard) {
        const moves = [];
        if (gameWon) return moves;

        if (currentActiveBoard !== null) {
            for (let cellIndex = 0; cellIndex < 9; cellIndex++) {
                if (!boards[currentActiveBoard][cellIndex]) {
                    moves.push({ boardIndex: currentActiveBoard, cellIndex });
                }
            }
        } else {
            for (let boardIndex = 0; boardIndex < 9; boardIndex++) {
                if (boardWinners[boardIndex]) continue;
                for (let cellIndex = 0; cellIndex < 9; cellIndex++) {
                    if (!boards[boardIndex][cellIndex]) {
                        moves.push({ boardIndex, cellIndex });
                    }
                }
            }
        }
        return moves;
    }

    function checkSmallBoardWin(boardIndex, player) {
        const board = boards[boardIndex];
        return winPatterns.some(pattern =>
            pattern.every(index => board[index] === player)
        );
    }

    function checkUltimateWin(player) {
        return winPatterns.some(pattern =>
            pattern.every(index => boardWinners[index] === player)
        );
    }

    function isBoardFull(boardIndex) {
        return boards[boardIndex].every(cell => cell !== '');
    }

    function checkDraw() {
        for(let i = 0; i < 9; i++) {
            if (boardWinners[i] === null && !isBoardFull(i)) {
                return false;
            }
        }
        return !checkUltimateWin('X') && !checkUltimateWin('O');
    }

    function updateActiveBoards() {
        document.querySelectorAll('.small-board').forEach((board, index) => {
            board.classList.remove('active');
            if (!boardWinners[index] && (activeBoard === null || activeBoard === index)) {
                board.classList.add('active');
            }
        });
    }

    function updateBoardHint() {
        const hint = document.getElementById('boardHint');
        if (gameWon) {
            hint.textContent = '';
            return;
        }

        if (gameMode === 'computer') {
            if (isMyTurn) {
                hint.style.color = '#4ade80';
                if (activeBoard === null) {
                    hint.textContent = '‚úÖ Dein Zug! W√§hle ein beliebiges freies Feld.';
                } else {
                    const row = Math.floor(activeBoard / 3) + 1;
                    const col = (activeBoard % 3) + 1;
                    hint.textContent = `‚úÖ Dein Zug! Spiele in Feld (${row}, ${col}).`;
                }
            } else {
                hint.style.color = '#fbbf24';
                hint.innerHTML = 'ü§ñ KI denkt nach<span class="thinking"></span>';
            }
        }
    }

    function disableSmallBoard(boardIndex) {
        for (let i = 0; i < 9; i++) {
            const cell = document.getElementById(`cell-${boardIndex}-${i}`);
            cell.disabled = true;
        }
    }

    function disableAllBoards() {
        for (let i = 0; i < 9; i++) {
            disableSmallBoard(i);
        }
        document.querySelectorAll('.small-board').forEach(b => b.classList.remove('active'));
    }

    function resetGame() {
        if (gameMode === 'online' && conn) {
            conn.send({ type: 'reset' });
        }

        currentPlayer = 'X';
        activeBoard = null;
        boards = Array(9).fill(null).map(() => Array(9).fill(''));
        boardWinners = Array(9).fill(null);
        gameWon = false;

        if (gameMode === 'computer') {
            mySymbol = 'X';
            opponentSymbol = 'O';
            isMyTurn = true;
        } else if (gameMode === 'online') {
            isMyTurn = mySymbol === 'X';
        }

        document.getElementById('currentPlayer').textContent = currentPlayer;
        document.getElementById('winnerMessage').textContent = '';

        initGame();
    }

    function backToMenu() {
        if (peer) {
            peer.destroy();
            peer = null;
        }
        if (conn) {
            conn.close();
            conn = null;
        }

        currentPlayer = 'X';
        activeBoard = null;
        boards = Array(9).fill(null).map(() => Array(9).fill(''));
        boardWinners = Array(9).fill(null);
        gameWon = false;
        isHost = false;
        mySymbol = '';
        opponentSymbol = '';
        isMyTurn = false;
        gameMode = '';

        document.getElementById('modeSelector').classList.remove('hidden');
        document.getElementById('connectionPanel').classList.add('hidden');
        document.getElementById('hostSection').classList.add('hidden');
        document.getElementById('joinSection').classList.add('hidden');
        document.getElementById('gameInfo').classList.add('hidden');
        document.getElementById('ultimateBoard').classList.remove('active');
        document.getElementById('gameButtons').classList.add('hidden');
        document.getElementById('winnerMessage').textContent = '';
        document.getElementById('connectionStatus').textContent = '';
        document.getElementById('connectionStatus').classList.remove('connected');
        document.getElementById('joinCode').value = '';
    }

    // Initialisierung
    document.getElementById('gameBoard').innerHTML = 'üì± W√§hle einen Spielmodus';

    // Verhindere Zoom auf iOS beim Doppeltippen
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function (event) {
        const now = Date.now();
        if (now - lastTouchEnd <= 300) {
            event.preventDefault();
        }
        lastTouchEnd = now;
    }, false);

    // Verhindere Pull-to-Refresh
    document.body.addEventListener('touchmove', function(e) {
        if (e.target.closest('.ultimate-board')) {
            e.preventDefault();
        }
    }, { passive: false });
</script>
</body>
</html>