<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ultimate Tic Tac Toe - Mobile Edition</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <link rel="stylesheet" href="style.css">

</head>
<body>
<div class="game-container">
    <h1>Ultimate Tic Tac Toe</h1>

    <div id="modeSelector" class="mode-selector">
        <h2 style="text-align: center; margin-bottom: 20px;">W√§hle einen Spielmodus:</h2>
        <button class="mode-button host" onclick="showHostPanel()">üéÆ Online-Spiel erstellen</button>
        <button class="mode-button join" onclick="showJoinPanel()">üîó Online-Spiel beitreten</button>
        <button class="mode-button computer" onclick="startComputerGame()">ü§ñ Gegen UNBESIEGBARE KI</button>
    </div>

    <div id="connectionPanel" class="connection-panel hidden">
        <h2 id="connectionTitle">Verbindung</h2>

        <div id="hostSection" class="hidden">
            <p>Teile diesen Code mit deinem Freund:</p>
            <div class="game-code" id="gameCode">Wird generiert...</div>
            <div class="status waiting">Warte auf Mitspieler...</div>
        </div>

        <div id="joinSection" class="hidden">
            <p>Gib den Spiel-Code ein:</p>
            <input type="text" id="joinCode" class="connection-input" placeholder="Spiel-Code eingeben" autocomplete="off">
            <button class="connection-button" onclick="joinGame()">Spiel beitreten</button>
        </div>

        <div id="connectionStatus" class="status"></div>
    </div>

    <div class="info hidden" id="gameInfo">
        <div>Du spielst als: <span id="playerSymbol" style="font-weight: bold;"></span></div>
        <div>Aktueller Spieler: <span class="current-player" id="currentPlayer">X</span></div>
        <div id="boardHint"></div>
    </div>

    <div class="ultimate-board" id="ultimateBoard">
        <div class="big-grid" id="gameBoard"></div>
    </div>

    <div id="winnerMessage" class="winner-message"></div>

    <div class="button-group hidden" id="gameButtons">
        <button class="reset-button" onclick="resetGame()">üîÑ Neues Spiel</button>
        <button class="back-button" onclick="backToMenu()">üè† Hauptmen√º</button>
    </div>
</div>

<script>
    let peer = null;
    let conn = null;
    let isHost = false;
    let mySymbol = '';
    let opponentSymbol = '';
    let isMyTurn = false;
    let gameMode = '';

    let currentPlayer = 'X';
    let activeBoard = null;
    let boards = Array(9).fill(null).map(() => Array(9).fill(''));
    let boardWinners = Array(9).fill(null);
    let gameWon = false;

    const winPatterns = [
        [0, 1, 2], [3, 4, 5], [6, 7, 8],
        [0, 3, 6], [1, 4, 7], [2, 5, 8],
        [0, 4, 8], [2, 4, 6]
    ];

    function generateGameCode() {
        return Math.random().toString(36).substring(2, 8).toUpperCase();
    }

    function showHostPanel() {
        gameMode = 'online';
        document.getElementById('modeSelector').classList.add('hidden');
        document.getElementById('connectionPanel').classList.remove('hidden');
        document.getElementById('hostSection').classList.remove('hidden');
        document.getElementById('connectionTitle').textContent = 'üéÆ Spiel erstellen';

        const gameCode = generateGameCode();
        peer = new Peer(gameCode);

        peer.on('open', (id) => {
            document.getElementById('gameCode').textContent = id;
            console.log('Game code:', id);
        });

        peer.on('connection', (connection) => {
            conn = connection;
            setupConnection();
            isHost = true;
            mySymbol = 'X';
            opponentSymbol = 'O';
            isMyTurn = true;
        });
    }

    function showJoinPanel() {
        gameMode = 'online';
        document.getElementById('modeSelector').classList.add('hidden');
        document.getElementById('connectionPanel').classList.remove('hidden');
        document.getElementById('joinSection').classList.remove('hidden');
        document.getElementById('connectionTitle').textContent = 'üîó Spiel beitreten';
    }

    function joinGame() {
        const code = document.getElementById('joinCode').value.toUpperCase();
        if (!code) {
            alert('Bitte gib einen Spiel-Code ein!');
            return;
        }

        peer = new Peer();

        peer.on('open', () => {
            conn = peer.connect(code);
            setupConnection();
            isHost = false;
            mySymbol = 'O';
            opponentSymbol = 'X';
            isMyTurn = false;
        });
    }

    function setupConnection() {
        conn.on('open', () => {
            document.getElementById('connectionStatus').textContent = '‚úÖ Verbunden!';
            document.getElementById('connectionStatus').classList.add('connected');
            startOnlineGame();
        });

        conn.on('data', (data) => {
            if (data.type === 'move') {
                receiveMove(data.boardIndex, data.cellIndex);
            } else if (data.type === 'reset') {
                resetGame();
            }
        });

        conn.on('close', () => {
            document.getElementById('connectionStatus').textContent = '‚ùå Verbindung getrennt!';
            document.getElementById('connectionStatus').classList.remove('connected');
            alert('Die Verbindung wurde getrennt!');
        });
    }

    function startOnlineGame() {
        document.getElementById('connectionPanel').classList.add('hidden');
        document.getElementById('gameInfo').classList.remove('hidden');
        document.getElementById('ultimateBoard').classList.add('active');
        document.getElementById('gameButtons').classList.remove('hidden');

        document.getElementById('playerSymbol').textContent = mySymbol;
        document.getElementById('playerSymbol').style.color = mySymbol === 'X' ? '#60a5fa' : '#f87171';

        initGame();
        updateTurnIndicator();
    }

    function startComputerGame() {
        gameMode = 'computer';
        document.getElementById('modeSelector').classList.add('hidden');
        document.getElementById('gameInfo').classList.remove('hidden');
        document.getElementById('ultimateBoard').classList.add('active');
        document.getElementById('gameButtons').classList.remove('hidden');

        document.getElementById('playerSymbol').textContent = 'X (Du)';
        document.getElementById('playerSymbol').style.color = '#60a5fa';

        mySymbol = 'X';
        opponentSymbol = 'O';
        isMyTurn = true;

        initGame();
    }

    function updateTurnIndicator() {
        if (gameMode === 'online') {
            const boardHint = document.getElementById('boardHint');
            if (isMyTurn) {
                boardHint.style.color = '#4ade80';
                if (activeBoard === null) {
                    boardHint.textContent = '‚úÖ Dein Zug! W√§hle ein beliebiges freies Feld.';
                } else {
                    const row = Math.floor(activeBoard / 3) + 1;
                    const col = (activeBoard % 3) + 1;
                    boardHint.textContent = `‚úÖ Dein Zug! Spiele in Feld (${row}, ${col}).`;
                }
            } else {
                boardHint.style.color = '#fbbf24';
                boardHint.innerHTML = '‚è≥ Warte auf deinen Gegner...';
            }
        } else {
            updateBoardHint();
        }
    }

    function initGame() {
        const gameBoard = document.getElementById('gameBoard');
        gameBoard.innerHTML = '';

        for (let boardIndex = 0; boardIndex < 9; boardIndex++) {
            const smallBoard = document.createElement('div');
            smallBoard.className = 'small-board';
            smallBoard.id = `board-${boardIndex}`;

            const smallGrid = document.createElement('div');
            smallGrid.className = 'small-grid';

            for (let cellIndex = 0; cellIndex < 9; cellIndex++) {
                const cell = document.createElement('button');
                cell.className = 'cell';
                cell.onclick = () => makeMove(boardIndex, cellIndex);
                cell.id = `cell-${boardIndex}-${cellIndex}`;
                smallGrid.appendChild(cell);
            }

            smallBoard.appendChild(smallGrid);
            gameBoard.appendChild(smallBoard);
        }
        updateActiveBoards();
        if (gameMode === 'online') {
            updateTurnIndicator();
        } else {
            updateBoardHint();
        }
    }

    function makeMove(boardIndex, cellIndex) {
        if (gameWon || boards[boardIndex][cellIndex] || boardWinners[boardIndex]) return;
        if (activeBoard !== null && activeBoard !== boardIndex) return;

        if (gameMode === 'online') {
            if (!isMyTurn || currentPlayer !== mySymbol) return;
            conn.send({ type: 'move', boardIndex, cellIndex });
        } else if (gameMode === 'computer') {
            if (currentPlayer !== mySymbol) return;
        }

        executeMove(boardIndex, cellIndex);
    }

    function receiveMove(boardIndex, cellIndex) {
        executeMove(boardIndex, cellIndex);
    }

    function executeMove(boardIndex, cellIndex) {
        boards[boardIndex][cellIndex] = currentPlayer;
        const cell = document.getElementById(`cell-${boardIndex}-${cellIndex}`);
        cell.textContent = currentPlayer;
        cell.classList.add(currentPlayer);
        cell.disabled = true;

        if (checkSmallBoardWin(boardIndex, currentPlayer)) {
            boardWinners[boardIndex] = currentPlayer;
            const smallBoard = document.getElementById(`board-${boardIndex}`);
            smallBoard.classList.add(`won-${currentPlayer}`);

            const winnerSymbol = document.createElement('div');
            winnerSymbol.className = 'board-winner';
            winnerSymbol.textContent = currentPlayer;
            winnerSymbol.style.color = currentPlayer === 'X' ? '#60a5fa' : '#f87171';
            smallBoard.appendChild(winnerSymbol);
            disableSmallBoard(boardIndex);

            if (checkUltimateWin(currentPlayer)) {
                gameWon = true;
                const winnerText = gameMode === 'online'
                    ? (currentPlayer === mySymbol ? 'üéâ Du hast gewonnen! üéâ' : 'üòî Dein Gegner hat gewonnen!')
                    : (currentPlayer === mySymbol ? 'üéâ Du hast gewonnen! üéâ' : 'ü§ñ Die KI hat gewonnen!');
                document.getElementById('winnerMessage').textContent = winnerText;
                disableAllBoards();
                return;
            }
        }

        if (checkDraw()) {
            gameWon = true;
            document.getElementById('winnerMessage').textContent = 'ü§ù Unentschieden!';
            return;
        }

        currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
        document.getElementById('currentPlayer').textContent = currentPlayer;

        activeBoard = boardWinners[cellIndex] !== null || isBoardFull(cellIndex) ? null : cellIndex;

        updateActiveBoards();

        if (gameMode === 'online') {
            isMyTurn = !isMyTurn;
            updateTurnIndicator();
        } else {
            isMyTurn = !isMyTurn;
            updateBoardHint();
            if (!isMyTurn && !gameWon) {
                document.getElementById('ultimateBoard').style.pointerEvents = 'none';
                setTimeout(() => {
                    makeComputerMove();
                    document.getElementById('ultimateBoard').style.pointerEvents = 'auto';
                }, 300);
            }
        }
    }

    // Computer AI Logic
    function makeComputerMove() {
        if (gameWon) return;

        const searchDepth = 6;
        let bestMove = { score: -Infinity, move: null };
        const availableMoves = getAvailableMoves();

        if (availableMoves.length === 0) return;
        if (availableMoves.length === 1) {
            bestMove.move = availableMoves[0];
        } else {
            for (const move of availableMoves) {
                boards[move.boardIndex][move.cellIndex] = opponentSymbol;
                const oldWinner = boardWinners[move.boardIndex];
                if (checkSmallBoardWin(move.boardIndex, opponentSymbol)) {
                    boardWinners[move.boardIndex] = opponentSymbol;
                }

                const score = minimax(searchDepth, false, -Infinity, Infinity, move);

                boards[move.boardIndex][move.cellIndex] = '';
                boardWinners[move.boardIndex] = oldWinner;

                if (score > bestMove.score) {
                    bestMove.score = score;
                    bestMove.move = move;
                }
            }
        }

        if (!bestMove.move) {
            bestMove.move = availableMoves[Math.floor(Math.random() * availableMoves.length)];
        }

        executeMove(bestMove.move.boardIndex, bestMove.move.cellIndex);
    }

    function minimax(depth, isMaximizing, alpha, beta, lastMove) {
        const score = evaluateBoard();
        if (Math.abs(score) > 5000 || depth === 0 || gameWon) {
            return score + depth;
        }

        const nextActiveBoard = (boardWinners[lastMove.cellIndex] !== null || isBoardFull(lastMove.cellIndex)) ? null : lastMove.cellIndex;
        const moves = getAvailableMoves(nextActiveBoard);

        if (isMaximizing) {
            let maxEval = -Infinity;
            for (const move of moves) {
                boards[move.boardIndex][move.cellIndex] = opponentSymbol;
                const oldWinner = boardWinners[move.boardIndex];
                if (checkSmallBoardWin(move.boardIndex, opponentSymbol)) {
                    boardWinners[move.boardIndex] = opponentSymbol;
                }

                const evaluation = minimax(depth - 1, false, alpha, beta, move);

                boards[move.boardIndex][move.cellIndex] = '';
                boardWinners[move.boardIndex] = oldWinner;

                maxEval = Math.max(maxEval, evaluation);
                alpha = Math.max(alpha, evaluation);
                if (beta <= alpha) break;
            }
            return maxEval;
        } else {
            let minEval = Infinity;
            for (const move of moves) {
                boards[move.boardIndex][move.cellIndex] = mySymbol;
                const oldWinner = boardWinners[move.boardIndex];
                if (checkSmallBoardWin(move.boardIndex, mySymbol)) {
                    boardWinners[move.boardIndex] = mySymbol;
                }

                const evaluation = minimax(depth - 1, true, alpha, beta, move);

                boards[move.boardIndex][move.cellIndex] = '';
                boardWinners[move.boardIndex] = oldWinner;

                minEval = Math.min(minEval, evaluation);
                beta = Math.min(beta, evaluation);
                if (beta <= alpha) break;
            }
            return minEval;
        }
    }

    function evaluateBoard() {
        if (checkUltimateWin(opponentSymbol)) return 10000;
        if (checkUltimateWin(mySymbol)) return -10000;

        let totalScore = 0;
        totalScore += evaluateLine(boardWinners, opponentSymbol, mySymbol) * 150;

        for (let i = 0; i < 9; i++) {
            if (boardWinners[i] === null) {
                totalScore += evaluateSmallBoard(i);
            }
        }

        return totalScore;
    }

    function evaluateLine(board, p1, p2) {
        let score = 0;
        for (const pattern of winPatterns) {
            let p1_pieces = 0;
            let p2_pieces = 0;
            for (const index of pattern) {
                if (board[index] === p1) p1_pieces++;
                else if (board[index] === p2) p2_pieces++;
            }
            if (p1_pieces === 2 && p2_pieces === 0) score += 1;
            if (p2_pieces === 2 && p1_pieces === 0) score -= 1;
        }
        return score;
    }

    function evaluateSmallBoard(boardIndex) {
        let score = 0;
        const board = boards[boardIndex];

        score += evaluateLine(board, opponentSymbol, mySymbol) * 10;

        if(board[4] === opponentSymbol) score += 4;
        else if(board[4] === mySymbol) score -= 4;

        const corners = [0, 2, 6, 8];
        corners.forEach(corner => {
            if(board[corner] === opponentSymbol) score += 2;
            else if(board[corner] === mySymbol) score -= 2;
        });

        if (boardIndex === 4) {
            return score * 1.5;
        }

        return score;
    }

    function getAvailableMoves(currentActiveBoard = activeBoard) {
        const moves = [];
        if (gameWon) return moves;

        if (currentActiveBoard !== null) {
            for (let cellIndex = 0; cellIndex < 9; cellIndex++) {
                if (!boards[currentActiveBoard][cellIndex]) {
                    moves.push({ boardIndex: currentActiveBoard, cellIndex });
                }
            }
        } else {
            for (let boardIndex = 0; boardIndex < 9; boardIndex++) {
                if (boardWinners[boardIndex]) continue;
                for (let cellIndex = 0; cellIndex < 9; cellIndex++) {
                    if (!boards[boardIndex][cellIndex]) {
                        moves.push({ boardIndex, cellIndex });
                    }
                }
            }
        }
        return moves;
    }

    function checkSmallBoardWin(boardIndex, player) {
        const board = boards[boardIndex];
        return winPatterns.some(pattern =>
            pattern.every(index => board[index] === player)
        );
    }

    function checkUltimateWin(player) {
        return winPatterns.some(pattern =>
            pattern.every(index => boardWinners[index] === player)
        );
    }

    function isBoardFull(boardIndex) {
        return boards[boardIndex].every(cell => cell !== '');
    }

    function checkDraw() {
        for(let i = 0; i < 9; i++) {
            if (boardWinners[i] === null && !isBoardFull(i)) {
                return false;
            }
        }
        return !checkUltimateWin('X') && !checkUltimateWin('O');
    }

    function updateActiveBoards() {
        document.querySelectorAll('.small-board').forEach((board, index) => {
            board.classList.remove('active');
            if (!boardWinners[index] && (activeBoard === null || activeBoard === index)) {
                board.classList.add('active');
            }
        });
    }

    function updateBoardHint() {
        const hint = document.getElementById('boardHint');
        if (gameWon) {
            hint.textContent = '';
            return;
        }

        if (gameMode === 'computer') {
            if (isMyTurn) {
                hint.style.color = '#4ade80';
                if (activeBoard === null) {
                    hint.textContent = '‚úÖ Dein Zug! W√§hle ein beliebiges freies Feld.';
                } else {
                    const row = Math.floor(activeBoard / 3) + 1;
                    const col = (activeBoard % 3) + 1;
                    hint.textContent = `‚úÖ Dein Zug! Spiele in Feld (${row}, ${col}).`;
                }
            } else {
                hint.style.color = '#fbbf24';
                hint.innerHTML = 'ü§ñ KI denkt nach<span class="thinking"></span>';
            }
        }
    }

    function disableSmallBoard(boardIndex) {
        for (let i = 0; i < 9; i++) {
            const cell = document.getElementById(`cell-${boardIndex}-${i}`);
            cell.disabled = true;
        }
    }

    function disableAllBoards() {
        for (let i = 0; i < 9; i++) {
            disableSmallBoard(i);
        }
        document.querySelectorAll('.small-board').forEach(b => b.classList.remove('active'));
    }

    function resetGame() {
        if (gameMode === 'online' && conn) {
            conn.send({ type: 'reset' });
        }

        currentPlayer = 'X';
        activeBoard = null;
        boards = Array(9).fill(null).map(() => Array(9).fill(''));
        boardWinners = Array(9).fill(null);
        gameWon = false;

        if (gameMode === 'computer') {
            mySymbol = 'X';
            opponentSymbol = 'O';
            isMyTurn = true;
        } else if (gameMode === 'online') {
            isMyTurn = mySymbol === 'X';
        }

        document.getElementById('currentPlayer').textContent = currentPlayer;
        document.getElementById('winnerMessage').textContent = '';

        initGame();
    }

    function backToMenu() {
        if (peer) {
            peer.destroy();
            peer = null;
        }
        if (conn) {
            conn.close();
            conn = null;
        }

        currentPlayer = 'X';
        activeBoard = null;
        boards = Array(9).fill(null).map(() => Array(9).fill(''));
        boardWinners = Array(9).fill(null);
        gameWon = false;
        isHost = false;
        mySymbol = '';
        opponentSymbol = '';
        isMyTurn = false;
        gameMode = '';

        document.getElementById('modeSelector').classList.remove('hidden');
        document.getElementById('connectionPanel').classList.add('hidden');
        document.getElementById('hostSection').classList.add('hidden');
        document.getElementById('joinSection').classList.add('hidden');
        document.getElementById('gameInfo').classList.add('hidden');
        document.getElementById('ultimateBoard').classList.remove('active');
        document.getElementById('gameButtons').classList.add('hidden');
        document.getElementById('winnerMessage').textContent = '';
        document.getElementById('connectionStatus').textContent = '';
        document.getElementById('connectionStatus').classList.remove('connected');
        document.getElementById('joinCode').value = '';
    }

    // Initialisierung
    document.getElementById('gameBoard').innerHTML = 'üì± W√§hle einen Spielmodus';

    // Verhindere Zoom auf iOS beim Doppeltippen
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function (event) {
        const now = Date.now();
        if (now - lastTouchEnd <= 300) {
            event.preventDefault();
        }
        lastTouchEnd = now;
    }, false);

    // Verhindere Pull-to-Refresh
    document.body.addEventListener('touchmove', function(e) {
        if (e.target.closest('.ultimate-board')) {
            e.preventDefault();
        }
    }, { passive: false });
</script>
</body>
</html>