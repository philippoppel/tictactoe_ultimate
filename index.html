<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Tic Tac Toe - Unbeatable AI</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #1a1a2e;
            color: #eee;
        }

        .game-container {
            text-align: center;
            padding: 20px;
        }

        h1 {
            color: #f39c12;
            margin-bottom: 10px;
        }

        .connection-panel {
            background-color: #0f3460;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        .connection-panel h2 {
            margin-top: 0;
            color: #f39c12;
        }

        .connection-input {
            padding: 10px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background-color: #16213e;
            color: #eee;
            font-size: 16px;
        }

        .connection-button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background-color: #3498db;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .connection-button:hover {
            background-color: #2980b9;
            transform: scale(1.05);
        }

        .connection-button.host {
            background-color: #27ae60;
        }

        .connection-button.host:hover {
            background-color: #229954;
        }

        .game-code {
            font-size: 24px;
            font-weight: bold;
            color: #f39c12;
            margin: 10px 0;
            padding: 10px;
            background-color: #16213e;
            border-radius: 5px;
        }

        .status {
            margin: 10px 0;
            font-size: 18px;
        }

        .status.connected {
            color: #27ae60;
        }

        .status.waiting {
            color: #f39c12;
        }

        .info {
            margin-bottom: 20px;
            font-size: 18px;
        }

        .current-player {
            color: #3498db;
            font-weight: bold;
        }

        .ultimate-board {
            display: inline-block;
            background-color: #0f3460;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            opacity: 0.3;
            transition: opacity 0.3s ease;
        }

        .ultimate-board.active {
            opacity: 1;
        }

        .big-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .small-board {
            background-color: #16213e;
            padding: 5px;
            border-radius: 5px;
            border: 3px solid #16213e;
            transition: all 0.3s ease;
        }

        .small-board.active {
            border-color: #f39c12;
            box-shadow: 0 0 10px #f39c12;
        }

        .small-board.won-X {
            background-color: rgba(52, 152, 219, 0.3);
        }

        .small-board.won-O {
            background-color: rgba(231, 76, 60, 0.3);
        }

        .small-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 3px;
        }

        .cell {
            width: 40px;
            height: 40px;
            background-color: #0f3460;
            border: none;
            cursor: pointer;
            font-size: 20px;
            font-weight: bold;
            color: #eee;
            transition: all 0.2s ease;
        }

        .cell:hover:not(:disabled) {
            background-color: #1e5490;
            transform: scale(1.1);
        }

        .cell:disabled {
            cursor: not-allowed;
            opacity: 0.7;
        }

        .cell.X {
            color: #3498db;
        }

        .cell.O {
            color: #e74c3c;
        }

        .winner-message {
            margin-top: 20px;
            font-size: 24px;
            font-weight: bold;
            color: #f39c12;
        }

        .reset-button {
            margin-top: 20px;
            padding: 10px 30px;
            font-size: 18px;
            background-color: #f39c12;
            color: #1a1a2e;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .reset-button:hover {
            background-color: #e67e22;
            transform: scale(1.05);
        }

        .board-winner {
            position: absolute;
            font-size: 80px;
            font-weight: bold;
            opacity: 0.8;
            pointer-events: none;
            transform: translate(-50%, -50%);
            top: 50%;
            left: 50%;
        }

        .small-board {
            position: relative;
        }

        .mode-selector {
            margin: 20px 0;
        }

        .mode-button {
            padding: 15px 30px;
            margin: 10px;
            border: none;
            border-radius: 5px;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-button.computer {
            background-color: #e74c3c;
            color: white;
        }

        .mode-button.computer:hover {
            background-color: #c0392b;
            transform: scale(1.05);
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
<div class="game-container">
    <h1>Ultimate Tic Tac Toe - Unbeatable AI</h1>

    <div id="modeSelector" class="mode-selector">
        <h2>W√§hle einen Spielmodus:</h2>
        <button class="mode-button host" onclick="showHostPanel()">Online-Spiel erstellen</button>
        <button class="mode-button connection-button" onclick="showJoinPanel()">Online-Spiel beitreten</button>
        <button class="mode-button computer" onclick="startComputerGame()">Gegen UNBESIEGBARE KI spielen</button>
    </div>

    <div id="connectionPanel" class="connection-panel hidden">
        <h2 id="connectionTitle">Verbindung</h2>

        <div id="hostSection" class="hidden">
            <p>Teile diesen Code mit deinem Freund:</p>
            <div class="game-code" id="gameCode">Wird generiert...</div>
            <div class="status waiting">Warte auf Mitspieler...</div>
        </div>

        <div id="joinSection" class="hidden">
            <p>Gib den Spiel-Code ein:</p>
            <input type="text" id="joinCode" class="connection-input" placeholder="Spiel-Code eingeben">
            <br>
            <button class="connection-button" onclick="joinGame()">Spiel beitreten</button>
        </div>

        <div id="connectionStatus" class="status"></div>
    </div>

    <div class="info hidden" id="gameInfo">
        <div>Du spielst als: <span id="playerSymbol" style="font-weight: bold;"></span></div>
        <div>Aktueller Spieler: <span class="current-player" id="currentPlayer">X</span></div>
        <div id="boardHint"></div>
    </div>

    <div class="ultimate-board" id="ultimateBoard">
        <div class="big-grid" id="gameBoard"></div>
    </div>

    <div id="winnerMessage" class="winner-message"></div>
    <button class="reset-button hidden" id="resetButton" onclick="resetGame()">Neues Spiel</button>
    <button class="reset-button hidden" id="backButton" onclick="backToMenu()">Zur√ºck zum Men√º</button>
</div>

<script>
    let peer = null;
    let conn = null;
    let isHost = false;
    let mySymbol = '';
    let opponentSymbol = '';
    let isMyTurn = false;
    let gameMode = ''; // 'online' oder 'computer'

    let currentPlayer = 'X';
    let activeBoard = null;
    let boards = Array(9).fill(null).map(() => Array(9).fill(''));
    let boardWinners = Array(9).fill(null);
    let gameWon = false;

    const winPatterns = [
        [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
        [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
        [0, 4, 8], [2, 4, 6]             // diagonals
    ];

    function generateGameCode() {
        return Math.random().toString(36).substring(2, 8).toUpperCase();
    }

    function showHostPanel() {
        gameMode = 'online';
        document.getElementById('modeSelector').classList.add('hidden');
        document.getElementById('connectionPanel').classList.remove('hidden');
        document.getElementById('hostSection').classList.remove('hidden');
        document.getElementById('connectionTitle').textContent = 'Spiel erstellen';

        const gameCode = generateGameCode();
        peer = new Peer(gameCode);

        peer.on('open', (id) => {
            document.getElementById('gameCode').textContent = id;
            console.log('Game code:', id);
        });

        peer.on('connection', (connection) => {
            conn = connection;
            setupConnection();
            isHost = true;
            mySymbol = 'X';
            opponentSymbol = 'O';
            isMyTurn = true;
        });
    }

    function showJoinPanel() {
        gameMode = 'online';
        document.getElementById('modeSelector').classList.add('hidden');
        document.getElementById('connectionPanel').classList.remove('hidden');
        document.getElementById('joinSection').classList.remove('hidden');
        document.getElementById('connectionTitle').textContent = 'Spiel beitreten';
    }

    function joinGame() {
        const code = document.getElementById('joinCode').value.toUpperCase();
        if (!code) {
            alert('Bitte gib einen Spiel-Code ein!');
            return;
        }

        peer = new Peer();

        peer.on('open', () => {
            conn = peer.connect(code);
            setupConnection();
            isHost = false;
            mySymbol = 'O';
            opponentSymbol = 'X';
            isMyTurn = false;
        });
    }

    function setupConnection() {
        conn.on('open', () => {
            document.getElementById('connectionStatus').textContent = 'Verbunden!';
            document.getElementById('connectionStatus').classList.add('connected');
            startOnlineGame();
        });

        conn.on('data', (data) => {
            if (data.type === 'move') {
                receiveMove(data.boardIndex, data.cellIndex);
            } else if (data.type === 'reset') {
                resetGame();
            }
        });

        conn.on('close', () => {
            document.getElementById('connectionStatus').textContent = 'Verbindung getrennt!';
            document.getElementById('connectionStatus').classList.remove('connected');
            alert('Die Verbindung wurde getrennt!');
        });
    }

    function startOnlineGame() {
        document.getElementById('connectionPanel').classList.add('hidden');
        document.getElementById('gameInfo').classList.remove('hidden');
        document.getElementById('ultimateBoard').classList.add('active');
        document.getElementById('resetButton').classList.remove('hidden');
        document.getElementById('backButton').classList.remove('hidden');

        document.getElementById('playerSymbol').textContent = mySymbol;
        document.getElementById('playerSymbol').style.color = mySymbol === 'X' ? '#3498db' : '#e74c3c';

        initGame();
        updateTurnIndicator();
    }

    function startComputerGame() {
        gameMode = 'computer';
        document.getElementById('modeSelector').classList.add('hidden');
        document.getElementById('gameInfo').classList.remove('hidden');
        document.getElementById('ultimateBoard').classList.add('active');
        document.getElementById('resetButton').classList.remove('hidden');
        document.getElementById('backButton').classList.remove('hidden');

        document.getElementById('playerSymbol').textContent = 'X (Du)';
        document.getElementById('playerSymbol').style.color = '#3498db';

        mySymbol = 'X';
        opponentSymbol = 'O';
        isMyTurn = true;

        initGame();
    }

    function updateTurnIndicator() {
        if (gameMode === 'online') {
            const boardHint = document.getElementById('boardHint');
            if (isMyTurn) {
                boardHint.style.color = '#27ae60';
                if (activeBoard === null) {
                    boardHint.textContent = 'Dein Zug! Du kannst in einem beliebigen freien Feld spielen.';
                } else {
                    const row = Math.floor(activeBoard / 3) + 1;
                    const col = (activeBoard % 3) + 1;
                    boardHint.textContent = `Dein Zug! Du musst im Feld (Zeile ${row}, Spalte ${col}) spielen.`;
                }
            } else {
                boardHint.style.color = '#e74c3c';
                boardHint.textContent = 'Warte auf den Zug deines Gegners...';
            }
        } else {
            updateBoardHint();
        }
    }

    function initGame() {
        const gameBoard = document.getElementById('gameBoard');
        gameBoard.innerHTML = '';

        for (let boardIndex = 0; boardIndex < 9; boardIndex++) {
            const smallBoard = document.createElement('div');
            smallBoard.className = 'small-board';
            smallBoard.id = `board-${boardIndex}`;

            const smallGrid = document.createElement('div');
            smallGrid.className = 'small-grid';

            for (let cellIndex = 0; cellIndex < 9; cellIndex++) {
                const cell = document.createElement('button');
                cell.className = 'cell';
                cell.onclick = () => makeMove(boardIndex, cellIndex);
                cell.id = `cell-${boardIndex}-${cellIndex}`;
                smallGrid.appendChild(cell);
            }

            smallBoard.appendChild(smallGrid);
            gameBoard.appendChild(smallBoard);
        }
        updateActiveBoards();
        if (gameMode === 'online') {
            updateTurnIndicator();
        } else {
            updateBoardHint();
        }
    }

    function makeMove(boardIndex, cellIndex) {
        if (gameWon || boards[boardIndex][cellIndex] || boardWinners[boardIndex]) return;
        if (activeBoard !== null && activeBoard !== boardIndex) return;

        if (gameMode === 'online') {
            if (!isMyTurn || currentPlayer !== mySymbol) return;
            conn.send({ type: 'move', boardIndex, cellIndex });
        } else if (gameMode === 'computer') {
            if (currentPlayer !== mySymbol) return;
        }

        executeMove(boardIndex, cellIndex);
    }

    function receiveMove(boardIndex, cellIndex) {
        executeMove(boardIndex, cellIndex);
    }

    function executeMove(boardIndex, cellIndex) {
        boards[boardIndex][cellIndex] = currentPlayer;
        const cell = document.getElementById(`cell-${boardIndex}-${cellIndex}`);
        cell.textContent = currentPlayer;
        cell.classList.add(currentPlayer);
        cell.disabled = true;

        if (checkSmallBoardWin(boardIndex, currentPlayer)) {
            boardWinners[boardIndex] = currentPlayer;
            const smallBoard = document.getElementById(`board-${boardIndex}`);
            smallBoard.classList.add(`won-${currentPlayer}`);

            const winnerSymbol = document.createElement('div');
            winnerSymbol.className = 'board-winner';
            winnerSymbol.textContent = currentPlayer;
            winnerSymbol.style.color = currentPlayer === 'X' ? '#3498db' : '#e74c3c';
            smallBoard.appendChild(winnerSymbol);
            disableSmallBoard(boardIndex);

            if (checkUltimateWin(currentPlayer)) {
                gameWon = true;
                const winnerText = gameMode === 'online'
                    ? (currentPlayer === mySymbol ? 'Du hast gewonnen! üéâ' : 'Dein Gegner hat gewonnen!')
                    : (currentPlayer === mySymbol ? 'Du hast gewonnen! üéâ' : 'Der Computer hat gewonnen!');
                document.getElementById('winnerMessage').textContent = winnerText;
                disableAllBoards();
                return;
            }
        }

        if (checkDraw()) {
            gameWon = true;
            document.getElementById('winnerMessage').textContent = 'Unentschieden!';
            return;
        }

        currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
        document.getElementById('currentPlayer').textContent = currentPlayer;

        activeBoard = boardWinners[cellIndex] !== null || isBoardFull(cellIndex) ? null : cellIndex;

        updateActiveBoards();

        if (gameMode === 'online') {
            isMyTurn = !isMyTurn;
            updateTurnIndicator();
        } else {
            isMyTurn = !isMyTurn;
            updateBoardHint();
            if (!isMyTurn && !gameWon) {
                document.getElementById('ultimateBoard').style.pointerEvents = 'none';
                setTimeout(() => {
                    makeComputerMove();
                    document.getElementById('ultimateBoard').style.pointerEvents = 'auto';
                }, 100); // K√ºrzere Wartezeit, da Berechnung l√§nger dauert
            }
        }
    }

    // #####################################################################
    // ################## UNBESIEGBARE COMPUTER-KI LOGIK ###################
    // #####################################################################

    function makeComputerMove() {
        if (gameWon) return;

        // --- √ÑNDERUNG: SUCHTIEFE ERH√ñHT ---
        // Eine h√∂here Suchtiefe macht die KI exponentiell st√§rker (und langsamer).
        // 6 ist f√ºr einen Menschen kaum noch zu schlagen.
        const searchDepth = 6;

        let bestMove = { score: -Infinity, move: null };
        const availableMoves = getAvailableMoves();

        if (availableMoves.length === 0) return;
        if (availableMoves.length === 1) {
            bestMove.move = availableMoves[0];
        } else {
            for (const move of availableMoves) {
                // Simuliere
                boards[move.boardIndex][move.cellIndex] = opponentSymbol;
                const oldWinner = boardWinners[move.boardIndex];
                if (checkSmallBoardWin(move.boardIndex, opponentSymbol)) {
                    boardWinners[move.boardIndex] = opponentSymbol;
                }

                const score = minimax(searchDepth, false, -Infinity, Infinity, move);

                // Mache r√ºckg√§ngig
                boards[move.boardIndex][move.cellIndex] = '';
                boardWinners[move.boardIndex] = oldWinner;

                if (score > bestMove.score) {
                    bestMove.score = score;
                    bestMove.move = move;
                }
            }
        }

        if (!bestMove.move) {
            bestMove.move = availableMoves[Math.floor(Math.random() * availableMoves.length)];
        }

        executeMove(bestMove.move.boardIndex, bestMove.move.cellIndex);
    }

    function minimax(depth, isMaximizing, alpha, beta, lastMove) {
        const score = evaluateBoard();
        if (Math.abs(score) > 5000 || depth === 0 || gameWon) {
            return score + depth; // Bonus f√ºr schnellere Siege
        }

        // Bestimme das n√§chste aktive Brett basierend auf dem letzten Zug
        const nextActiveBoard = (boardWinners[lastMove.cellIndex] !== null || isBoardFull(lastMove.cellIndex)) ? null : lastMove.cellIndex;
        const moves = getAvailableMoves(nextActiveBoard);

        if (isMaximizing) {
            let maxEval = -Infinity;
            for (const move of moves) {
                boards[move.boardIndex][move.cellIndex] = opponentSymbol;
                const oldWinner = boardWinners[move.boardIndex];
                if (checkSmallBoardWin(move.boardIndex, opponentSymbol)) {
                    boardWinners[move.boardIndex] = opponentSymbol;
                }

                const evaluation = minimax(depth - 1, false, alpha, beta, move);

                boards[move.boardIndex][move.cellIndex] = '';
                boardWinners[move.boardIndex] = oldWinner;

                maxEval = Math.max(maxEval, evaluation);
                alpha = Math.max(alpha, evaluation);
                if (beta <= alpha) break;
            }
            return maxEval;
        } else {
            let minEval = Infinity;
            for (const move of moves) {
                boards[move.boardIndex][move.cellIndex] = mySymbol;
                const oldWinner = boardWinners[move.boardIndex];
                if (checkSmallBoardWin(move.boardIndex, mySymbol)) {
                    boardWinners[move.boardIndex] = mySymbol;
                }

                const evaluation = minimax(depth - 1, true, alpha, beta, move);

                boards[move.boardIndex][move.cellIndex] = '';
                boardWinners[move.boardIndex] = oldWinner;

                minEval = Math.min(minEval, evaluation);
                beta = Math.min(beta, evaluation);
                if (beta <= alpha) break;
            }
            return minEval;
        }
    }

    function evaluateBoard() {
        // --- √ÑNDERUNG: VERBESSERTE HEURISTIK ---
        if (checkUltimateWin(opponentSymbol)) return 10000; // KI gewinnt
        if (checkUltimateWin(mySymbol)) return -10000;     // Spieler gewinnt

        let totalScore = 0;

        // Bewertung des Hauptbretts (wie ein normales Tic-Tac-Toe mit den Gewinnern der kleinen Bretter)
        totalScore += evaluateLine(boardWinners, opponentSymbol, mySymbol) * 150;

        for (let i = 0; i < 9; i++) {
            if (boardWinners[i] === null) {
                totalScore += evaluateSmallBoard(i);
            }
        }

        return totalScore;
    }

    function evaluateLine(board, p1, p2) {
        let score = 0;
        for (const pattern of winPatterns) {
            let p1_pieces = 0;
            let p2_pieces = 0;
            for (const index of pattern) {
                if (board[index] === p1) p1_pieces++;
                else if (board[index] === p2) p2_pieces++;
            }
            if (p1_pieces === 2 && p2_pieces === 0) score += 1;
            if (p2_pieces === 2 && p1_pieces === 0) score -= 1;
        }
        return score;
    }

    function evaluateSmallBoard(boardIndex) {
        let score = 0;
        const board = boards[boardIndex];

        // Starker Bonus/Malus f√ºr drohende Siege/Niederlagen auf diesem Brett
        score += evaluateLine(board, opponentSymbol, mySymbol) * 10;

        // Bonus f√ºr die Mitte des kleinen Brettes
        if(board[4] === opponentSymbol) score += 4;
        else if(board[4] === mySymbol) score -= 4;

        // Bonus f√ºr Ecken
        const corners = [0, 2, 6, 8];
        corners.forEach(corner => {
            if(board[corner] === opponentSymbol) score += 2;
            else if(board[corner] === mySymbol) score -= 2;
        });

        // Wenn dieses Brett das mittlere Hauptbrett ist, sind alle Boni mehr wert
        if (boardIndex === 4) {
            return score * 1.5;
        }

        return score;
    }

    function getAvailableMoves(currentActiveBoard = activeBoard) {
        const moves = [];
        if (gameWon) return moves;

        if (currentActiveBoard !== null) {
            for (let cellIndex = 0; cellIndex < 9; cellIndex++) {
                if (!boards[currentActiveBoard][cellIndex]) {
                    moves.push({ boardIndex: currentActiveBoard, cellIndex });
                }
            }
        } else { // Wenn √ºberall gespielt werden darf
            for (let boardIndex = 0; boardIndex < 9; boardIndex++) {
                if (boardWinners[boardIndex]) continue;
                for (let cellIndex = 0; cellIndex < 9; cellIndex++) {
                    if (!boards[boardIndex][cellIndex]) {
                        moves.push({ boardIndex, cellIndex });
                    }
                }
            }
        }
        return moves;
    }

    // ####################### ENDE DER NEUEN KI-LOGIK #####################
    // #####################################################################


    function checkSmallBoardWin(boardIndex, player) {
        const board = boards[boardIndex];
        return winPatterns.some(pattern =>
            pattern.every(index => board[index] === player)
        );
    }

    function checkUltimateWin(player) {
        return winPatterns.some(pattern =>
            pattern.every(index => boardWinners[index] === player)
        );
    }

    function isBoardFull(boardIndex) {
        return boards[boardIndex].every(cell => cell !== '');
    }

    function checkDraw() {
        for(let i = 0; i < 9; i++) {
            if (boardWinners[i] === null && !isBoardFull(i)) {
                return false;
            }
        }
        return !checkUltimateWin('X') && !checkUltimateWin('O');
    }

    function updateActiveBoards() {
        document.querySelectorAll('.small-board').forEach((board, index) => {
            board.classList.remove('active');
            if (!boardWinners[index] && (activeBoard === null || activeBoard === index)) {
                board.classList.add('active');
            }
        });
    }

    function updateBoardHint() {
        const hint = document.getElementById('boardHint');
        if (gameWon) {
            hint.textContent = '';
            return;
        }

        if (gameMode === 'computer') {
            if (isMyTurn) {
                hint.style.color = '#27ae60';
                if (activeBoard === null) {
                    hint.textContent = 'Dein Zug! Du kannst in einem beliebigen freien Feld spielen.';
                } else {
                    const row = Math.floor(activeBoard / 3) + 1;
                    const col = (activeBoard % 3) + 1;
                    hint.textContent = `Dein Zug! Du musst im Feld (Zeile ${row}, Spalte ${col}) spielen.`;
                }
            } else {
                hint.style.color = '#e74c3c';
                hint.textContent = 'Der Computer berechnet seinen optimalen Zug...';
            }
        }
    }

    function disableSmallBoard(boardIndex) {
        for (let i = 0; i < 9; i++) {
            const cell = document.getElementById(`cell-${boardIndex}-${i}`);
            cell.disabled = true;
        }
    }

    function disableAllBoards() {
        for (let i = 0; i < 9; i++) {
            disableSmallBoard(i);
        }
        document.querySelectorAll('.small-board').forEach(b => b.classList.remove('active'));
    }

    function resetGame() {
        if (gameMode === 'online' && conn) {
            conn.send({ type: 'reset' });
        }

        currentPlayer = 'X';
        activeBoard = null;
        boards = Array(9).fill(null).map(() => Array(9).fill(''));
        boardWinners = Array(9).fill(null);
        gameWon = false;

        if (gameMode === 'computer') {
            mySymbol = 'X';
            opponentSymbol = 'O';
            isMyTurn = true;
        } else if (gameMode === 'online') {
            isMyTurn = mySymbol === 'X';
        }

        document.getElementById('currentPlayer').textContent = currentPlayer;
        document.getElementById('winnerMessage').textContent = '';

        initGame();
    }

    function backToMenu() {
        if (peer) {
            peer.destroy();
            peer = null;
        }
        if (conn) {
            conn.close();
            conn = null;
        }

        currentPlayer = 'X';
        activeBoard = null;
        boards = Array(9).fill(null).map(() => Array(9).fill(''));
        boardWinners = Array(9).fill(null);
        gameWon = false;
        isHost = false;
        mySymbol = '';
        opponentSymbol = '';
        isMyTurn = false;
        gameMode = '';

        document.getElementById('modeSelector').classList.remove('hidden');
        document.getElementById('connectionPanel').classList.add('hidden');
        document.getElementById('hostSection').classList.add('hidden');
        document.getElementById('joinSection').classList.add('hidden');
        document.getElementById('gameInfo').classList.add('hidden');
        document.getElementById('ultimateBoard').classList.remove('active');
        document.getElementById('resetButton').classList.add('hidden');
        document.getElementById('backButton').classList.add('hidden');
        document.getElementById('winnerMessage').textContent = '';
        document.getElementById('connectionStatus').textContent = '';
        document.getElementById('connectionStatus').classList.remove('connected');
        document.getElementById('joinCode').value = '';
    }

    document.getElementById('gameBoard').innerHTML = 'W√§hle einen Spielmodus, um zu starten.';
</script>
</body>
</html>